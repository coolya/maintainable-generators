
<!DOCTYPE html>
<html>
<head>
  
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Best Practices &mdash; Towards Maintainable MPS Generators</title>

    <link rel="shortcut icon" href="../img/favicon.ico">
    <link rel="stylesheet" href="../css/alabaster.css" type="text/css">
    <link rel="stylesheet" href="../css/alabaster-overrides.css" type="text/css">

    

    
      <script src="../search/require.js"></script>
    
      <script src="../search/search.js"></script>
    

    

    <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

    
  
</head>
<body>

  <div class="document">
    <div class="documentwrapper">
      <div class="bodywrapper">
        <div class="body" role="main">
          
            <h1 id="best-practices">Best Practices</h1>
<h2 id="detecting-tests">Detecting Tests</h2>
<p>In some cases generators should not transform node when they are used in tests as some of their assumptions about the structure of their input might not hold in tests. Tests often test nodes in isolation which doesn't work well with more complex generators that depend on some context.</p>
<p>Use the <code>IsInTestsExpression</code> from the <code>com.mbeddr.mpsutil.blutil.genUtil</code> language, which is part of the MPS-extensions:</p>
<pre><code>is applicable:
    (genContext) -&gt; boolean {
        !is-in-tests;
    }
</code></pre>

<p>Or alternatively:</p>
<pre><code>--- is applicable ---
(genContext)-&gt;boolean {
  !genContext.originalModel.nodes(&lt;all&gt;).any({~it =&gt; it.concept.getLanguage().getQualifiedName().startsWith(&quot;jetbrains.mps.lang.test&quot;); });
}
</code></pre>

<p>If you use the later it might make sense to move this code into a helper class and use it that in the various places of your code bases.</p>
<h2 id="preprocessing">Preprocessing</h2>
<p>In scenarios where the structure of the input model is significantly different form the output structure it is often handy to use preprocessing scripts written in Java rather than reduction or weaving rules. Another sometimes useful benefit is that debugging Java code can be easier than the declarative and interpreted rules of the generator. </p>
<p>An example where preprocessing can make a lot of sense is inout collection for generation. If the generation target is for instance a XML file with a specific structure but the input model allows the user to freely place these elements preprocessing can collect all these contents and place them under a single node with a structure closer to the one of output. </p>
<p>In addition to using preprocessing for to change the structure of the input it is also handy to have intermediate language who's sole purpose is to ease generation. These languages often contain concepts that user does not need to specify explicitly in the input because they can be derived from the input. But during generation it often simplifies the generators if these elements are explicitly in the model because they can be generated by simple means of reduction rules. An example for this would be a generator that generates serialisation logic for data structures but could derive the data types for certain input automatically (e.g. boolean). The actual generator to produce the serialisation logic is much simpler to write when these data types are explicitly in the model. In this case the preprocessing would add these information.</p>
<p>Preprocessing comes at a cost, as it's not as declarative as the generator language tracing has to be done manually via the <code>TracingUtil</code>s <code>fillOriginalNode</code>. Also registering inputs and outputs to mapping label needs to be done explicitly via: <code>genContext.label input to output as myLabel;</code>. The generator is also not able to execute anything concurrently while a script is used. The usage of preprocessing scripts that heavily modify the model should be kept to a minimum. </p>
<h2 id="copy-and-reduce">Copy and Reduce</h2>
<h2 id="prefer-switches-over-ifs">Prefer Switches over Ifs</h2>
<h2 id="predefined-generator-plans">Predefined Generator Plans</h2>
<p>In some cases defining a static generation plan can be very useful and simplify the view on which generators are engaged at which point during the generation. Though this is mostly the last option one want to take. At the moment the extensibility story for predefined generator plans is pretty limited compared to the dynamic approach with priorities. Currently you can only contribute generators to the predefined plan via extension dependency to a generator that is involved in the generation plan this generator is the executed in the same step as the extended generator. It can also cause problems in conjunction with node/editor tests. If a Devkit with a generation plan and this DevKit is used in tests, this can cause that MPS would not consider the generators of the test language. As mentioned above this is a solution that currently doesn't widely apply especially not if your languages are meant to be extended. But in some contexts where extensibility is not the main concern or even undesired using predefined generation plans can help.</p>
            
          
        </div>
      </div>
    </div>
    <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
      <div class="sphinxsidebarwrapper">
        
  <h1 class="logo"><a href="..">Towards Maintainable MPS Generators</a></h1>



        
          



<h3>Table Of Contents</h3>

<nav>
  
  
    <ul>
    
      <li><a href="#detecting-tests">Detecting Tests</a></li>
      <ul>
    
  </ul>
    
      <li><a href="#preprocessing">Preprocessing</a></li>
      <ul>
    
  </ul>
    
      <li><a href="#copy-and-reduce">Copy and Reduce</a></li>
      <ul>
    
  </ul>
    
      <li><a href="#prefer-switches-over-ifs">Prefer Switches over Ifs</a></li>
      <ul>
    
  </ul>
    
      <li><a href="#predefined-generator-plans">Predefined Generator Plans</a></li>
      <ul>
    
  </ul>
    
  </ul>
  

  
</nav>
          
  <h3>Related Topics</h3>
  <ul>
    
      <li>Previous: <a href=".." title="previous chapter">
        Home
      </a></li>
    
    
      <li>Next: <a href="../Complex/" title="next chapter">
        Complex Multistage Generators
      </a></li>
    
  </ul>

        
        <div id="searchbox" style="display: none;" role="search">
  <h3>Quick search</h3>
  <form class="search" action="../search.html" method="get">
    <input name="q" type="text">
    <input value="Go" type="submit">
  </form>
  <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
  </p>
</div>
<script type="text/javascript">
  document.getElementById("searchbox").style.display = "block";
</script>
      </div>
    </div>
    <div class="clearer"></div>
  </div>

  
    <div class="footer">
      
      
        
        Powered by <a href="http://www.mkdocs.org">MkDocs 0.17.2</a>
        &amp; <a href="https://github.com/iamale/mkdocs-alabaster">Alabaster</a>
      
    </div>
  

  <!--
  MkDocs version      : 0.17.2
  Docs Build Date UTC : 2018-04-01 16:34:17
  -->
</body>
</html>