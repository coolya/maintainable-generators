
<!DOCTYPE html>
<html>
<head>
  
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Best Practices &mdash; Maintainable MPS Generators</title>

    <link rel="shortcut icon" href="../img/favicon.ico">
    <link rel="stylesheet" href="../css/alabaster.css" type="text/css">
    <link rel="stylesheet" href="../css/alabaster-overrides.css" type="text/css">

    

    
      <script src="../search/require.js"></script>
    
      <script src="../search/search.js"></script>
    

    

    <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

    
  
</head>
<body>

  <div class="document">
    <div class="documentwrapper">
      <div class="bodywrapper">
        <div class="body" role="main">
          
            <h1 id="best-practices">Best Practices</h1>
<h2 id="detecting-tests">Detecting Tests</h2>
<p>In some cases generators should not transform node when they are used in tests as some of their assumptions about the structure of their input might not hold in tests. Tests often test nodes in isolation which doesn't work well with more complex generators that depend on some context.</p>
<p>Use the <code>IsInTestsExpression</code> from the <code>com.mbeddr.mpsutil.blutil.genUtil</code> language, which is part of the MPS-extensions:</p>
<pre><code>is applicable:
    (genContext) -&gt; boolean {
        !is-in-tests;
    }
</code></pre>

<p>Or alternatively:</p>
<pre><code>--- is applicable ---
(genContext)-&gt;boolean {
  !genContext.originalModel.nodes(&lt;all&gt;).any({~it =&gt; it.concept.getLanguage().getQualifiedName().startsWith(&quot;jetbrains.mps.lang.test&quot;); });
}
</code></pre>

<p>If you use the later it might make sense to move this code into a helper class and use it that in the various places of your code bases.</p>
<h2 id="preprocessing">Preprocessing</h2>
<p>In scenarios where the structure of the input model is significantly different form the output structure it is often handy to use preprocessing scripts written in Java rather than reduction or weaving rules. Another sometimes useful benefit is that debugging Java code can be easier than the declarative and interpreted rules of the generator. </p>
<p>An example where preprocessing can make a lot of sense is inout collection for generation. If the generation target is for instance a XML file with a specific structure but the input model allows the user to freely place these elements preprocessing can collect all these contents and place them under a single node with a structure closer to the one of output. </p>
<p>In addition to using preprocessing for to change the structure of the input it is also handy to have intermediate language who's sole purpose is to ease generation. These languages often contain concepts that user does not need to specify explicitly in the input because they can be derived from the input. But during generation it often simplifies the generators if these elements are explicitly in the model because they can be generated by simple means of reduction rules. An example for this would be a generator that generates serialisation logic for data structures but could derive the data types for certain input automatically (e.g. boolean). The actual generator to produce the serialisation logic is much simpler to write when these data types are explicitly in the model. In this case the preprocessing would add these information.</p>
<p>Preprocessing comes at a cost, as it's not as declarative as the generator language tracing has to be done manually via the <code>TracingUtil</code>s <code>fillOriginalNode</code>. Also registering inputs and outputs to mapping label needs to be done explicitly via: <code>genContext.label input to output as myLabel;</code>. The generator is also not able to execute anything concurrently while a script is used. The usage of preprocessing scripts that heavily modify the model should be kept to a minimum. </p>
<h2 id="error-handling">Error Handling</h2>
<p>When reporting errors during generation the natural thing to use is exceptions as most of the code that is written in MPS generators is Java. But doing so has some disadvantages. </p>
<ul>
<li>It stops generation immediately. The user only get's single error message if there are multiple errors during generator the user can only fix the first, then has to regenerated, get the next error and start over. This can be a very frustrating process.</li>
<li>There is no way to point the user to the input that caused the error. The exception will contain a link to the rule that cause it but there is not additional information useful for the user to debug. If transient models are turned on the user might be able to see the intermediate state which caused the error but it's often hard to guess from the which node in the original model caused it.</li>
</ul>
<p>It is much better do something like this:</p>
<pre><code>genContext.show error &quot;something went wrong&quot; -&gt; genContext.get original copied input for (node)
</code></pre>

<p>This will stop generation after the current generation phase is complete. No other generators will execute afterwards, but it will collect all errors from the currently executed generator. It also allows to specify a node where the user is taken to when the messages is clicked. Together with the <code>genContext.get original copied input for (node)</code> pattern it takes the user directly to the input in the original model. </p>
<h2 id="copy-and-reduce">Copy and Reduce</h2>
<p>When generating output from a list of items or a single child node the first idea is often to use a <code>$LOOP$</code> macro or to do the transformation <em>in place</em>. While this looks easy in the first place it also limits extensibility. It is often much better to avoid this kind of pattern and use a combination for <code>$COPY_SRC$</code>/<code>$COPY_SRCL$</code> and a reduction rule for the concept. This allows extensions to contribute their own reduction rules for their concepts. Incase a <code>$LOOP$</code> macro would be used the only option to extend the generator would be to essentially copy the complete mapping and have the generator run before the one of the extended language is invoked. </p>
<p>Here is an example from the mpsutil codebase: </p>
<pre><code>new AfterExtension(&quot;$wizId&quot;, &quot;$stepId&quot;, new arraylist&lt;AbstractWizardStepEx&gt;{$LOOP$new -&gt;$dummy_step()})
</code></pre>

<p>It assumes that all elements of the <code>arraylist</code> are created by invoking a constructor of a class. If somebody wants to extend this behaviour and wants to include a singleton object into the list it's impossible. The code has been rewritten to:</p>
<pre><code>new AfterExtension(&quot;$wizId&quot;, &quot;$stepId&quot;, new arraylist&lt;AbstractWizardStepEx&gt;{$COPY_SRCL$new dummy_step()})

// and a reduction rule for the steps

concept Step       --&gt; &lt;T  new -&gt;$dummy_step()  T&gt; 

inheritors true                                     
condition &lt;always&gt;                                  

</code></pre>

<p>Another pattern to avoid this limitation is to use a <code>$LOOP$</code> macro but delegate the actual reduction into a template switch by calling it with a. <code>$SWITCH$</code> macro:</p>
<pre><code>new ConceptEvaluatorBase(concept/-&gt;$ConceptEvaluator/, $true, $LOOP$$SWITCH$ populateConstraintconstraints) { 
</code></pre>

<h2 id="prefer-switches-over-ifs">Prefer Switches over Ifs</h2>
<p>In cases where the generator should produce output based on a condition the common macro to use is usually the <code>$IF$</code> macro. There is nothing wrong with this per se but in cases where this condition is based on a model element other than a boolean property it is usually a smell that it should be replaced with a template switch. </p>
<p>The following example is from the mebddr codebase.</p>
<pre><code>$IF$return $COPY_SRC$null; / 
$ELSE$&lt;T  $COPY_SRCL$return;  T&gt;

--- inspector --- 
conditional branch                                                                                                    

comment : &lt;none&gt;                                                                                                      
mapping label : &lt;no label&gt;                                                                                            
condition : (genContext, node, operationContext)-&gt;boolean { 
  node.evaluator.isInstanceOf(ConceptEvaluatorInline); 
}
alternative : &lt;T  $COPY_SRCL$return;  T&gt;                                                                              
</code></pre>

<p>The code essentially checks what kind of concept is in the <code>evaluator</code> child role and then changes the way in which it generates the code. It handles the two cases that were assumed in the original language perfectly well, but in case we want to introduce a custom <code>Evaluator</code> it would fail. </p>
<p>is better rewritten like this:</p>
<pre><code>
// replacment for the $IF$

$SWITCH$ evaluatorImplementationreturn null;

--- inspector ---

switch templates by input node                                                  

comment : &lt;none&gt;                                                                
mapping label : &lt;no label&gt;                                                      
use input : (genContext, node, operationContext)-&gt;node&lt;&gt; { 
  node.evaluator; 
}

template switch : evaluatorImplementation                                       

// the template switch

template switch evaluatorImplementation extends &lt;none&gt;                  

parameters                                                              
&lt;&lt; ... &gt;&gt;                                                               

  null-input message: &lt;none&gt;                                            

  cases:                                                                

     concept ConceptEvaluatorInline --&gt; &lt;T  return $COPY_SRC$null;  T&gt; 

     inheritors true                                                    
     condition &lt;always&gt;                                                 
     concept ConceptEvaluatorBody --&gt; &lt;T  $COPY_SRCL$return;  T&gt; 

     inheritors true                                                    
     condition &lt;always&gt;                                                 


  default: DISMISS TOP RULE error : can not handle evaluator            


</code></pre>

<p>Note that the external template switch is extensible from other generators. By simply defining a extends relationship: <code>template switch mySwitch extends evaluatorImplementation</code>. This will contribute the additional cases each time the original switch is invoked. </p>
<p>In addition the original template switch, if it doesn't have a default case, wants to print an error message. Because otherwise the template switch invocation is replaced with node that has the <code>$SWITCH$</code> macro attached. This is done via a default rule that looks like this:</p>
<pre><code>default: DISMISS TOP RULE error : can not handle evaluator
</code></pre>

<h2 id="predefined-generator-plans">Predefined Generator Plans</h2>
<p>In some cases defining a static generation plan can be very useful and simplify the view on which generators are engaged at which point during the generation. Though this is mostly the last option one want to take. At the moment the extensibility story for predefined generator plans is pretty limited compared to the dynamic approach with priorities. Currently you can only contribute generators to the predefined plan via extension dependency to a generator that is involved in the generation plan this generator is the executed in the same step as the extended generator. It can also cause problems in conjunction with node/editor tests. If a DevKit with a generation plan and this DevKit is used in tests, this can cause that MPS would not consider the generators of the test language. As mentioned above this is a solution that currently doesn't widely apply especially not if your languages are meant to be extended. But in some contexts where extensibility is not the main concern or even undesired using predefined generation plans can help.</p>
            
          
        </div>
      </div>
    </div>
    <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
      <div class="sphinxsidebarwrapper">
        
  <h1 class="logo"><a href="..">Maintainable MPS Generators</a></h1>



  <p class="blurb">A guide towards maintainable MPS generators</p>

        
          



<h3>Table Of Contents</h3>

<nav>
  
  
    <ul>
    
      <li><a href="#detecting-tests">Detecting Tests</a></li>
      <ul>
    
  </ul>
    
      <li><a href="#preprocessing">Preprocessing</a></li>
      <ul>
    
  </ul>
    
      <li><a href="#error-handling">Error Handling</a></li>
      <ul>
    
  </ul>
    
      <li><a href="#copy-and-reduce">Copy and Reduce</a></li>
      <ul>
    
  </ul>
    
      <li><a href="#prefer-switches-over-ifs">Prefer Switches over Ifs</a></li>
      <ul>
    
  </ul>
    
      <li><a href="#predefined-generator-plans">Predefined Generator Plans</a></li>
      <ul>
    
  </ul>
    
  </ul>
  

  
    <hr>
    <ul>
      
        <li class="toctree-l1"><a href="https://github.com/coolya/maintainable-generators">Edit on GitHub</a></li>
      
    </ul>
  
</nav>
          
  <h3>Related Topics</h3>
  <ul>
    
      <li>Previous: <a href=".." title="previous chapter">
        Home
      </a></li>
    
    
      <li>Next: <a href="../Complex/" title="next chapter">
        Complex Multistage Generators
      </a></li>
    
  </ul>

        
        <div id="searchbox" style="display: none;" role="search">
  <h3>Quick search</h3>
  <form class="search" action="../search.html" method="get">
    <input name="q" type="text">
    <input value="Go" type="submit">
  </form>
  <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
  </p>
</div>
<script type="text/javascript">
  document.getElementById("searchbox").style.display = "block";
</script>
      </div>
    </div>
    <div class="clearer"></div>
  </div>

  
    <div class="footer">
      
      
    </div>
  

  <!--
  MkDocs version      : 0.17.2
  Docs Build Date UTC : 2018-04-20 08:22:51
  -->
</body>
</html>