
<!DOCTYPE html>
<html>
<head>
  
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">

    <title>Best Practices &mdash; Towards Maintainable MPS Generators</title>

    <link rel="shortcut icon" href="../img/favicon.ico">
    <link rel="stylesheet" href="../css/alabaster.css" type="text/css">
    <link rel="stylesheet" href="../css/alabaster-overrides.css" type="text/css">

    

    
      <script src="../search/require.js"></script>
    
      <script src="../search/search.js"></script>
    

    

    <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

    
  
</head>
<body>

  <div class="document">
    <div class="documentwrapper">
      <div class="bodywrapper">
        <div class="body" role="main">
          
            <h1 id="best-practices">Best Practices</h1>
<h2 id="detecting-tests">Detecting Tests</h2>
<p>In some cases generators should not transform node when they are used in tests as some of their assumptions about the structure of their input might not hold in tests. Tests often test nodes in isolation which doesn't work well with more complex generators that depend on some context.</p>
<p>Use the <code>IsInTestsExpression</code> from the <code>com.mbeddr.mpsutil.blutil.genUtil</code> language, which is part of the MPS-extensions:</p>
<pre><code>is applicable:
    (genContext) -&gt; boolean {
        !is-in-tests;
    }
</code></pre>

<p>Or alternatively:</p>
<pre><code>--- is applicable ---
(genContext)-&gt;boolean {
  !genContext.originalModel.nodes(&lt;all&gt;).any({~it =&gt; it.concept.getLanguage().getQualifiedName().startsWith(&quot;jetbrains.mps.lang.test&quot;); });
}
</code></pre>

<p>If you use the later it might make sense to move this code into a helper class and use it that in the various places of your code bases.</p>
<h2 id="preprocessing">Preprocessing</h2>
<p>In scenarios where the structure of the input model is significantly different form the output structure it is often handy to use preprocessing scripts written in Java rather than reduction or weaving rules. Another sometimes useful benefit is that debugging Java code can be easier than the declarative and interpreted rules of the generator. </p>
<p>An example where preprocessing can make a lot of sense is inout collection for generation. If the generation target is for instance a XML file with a specific structure but the input model allows the user to freely place these elements preprocessing can collect all these contents and place them under a single node with a structure closer to the one of output. </p>
<p>In addition to using preprocessing for to change the structure of the input it is also handy to have intermediate language who's sole purpose is to ease generation. These languages often contain concepts that user does not need to specify explicitly in the input because they can be derived from the input. But during generation it often simplifies the generators if these elements are explicitly in the model because they can be generated by simple means of reduction rules. An example for this would be a generator that generates serialisation logic for data structures but could derive the data types for certain input automatically (e.g. boolean). The actual generator to produce the serialisation logic is much simpler to write when these data types are explicitly in the model. In this case the preprocessing would add these information.</p>
<p>Preprocessing comes at a cost, as it's not as declarative as the generator language tracing has to be done manually via the <code>TracingUtil</code>s <code>fillOriginalNode</code>. Also registering inputs and outputs to mapping label needs to be done explicitly via: <code>genContext.label input to output as myLabel;</code>. The generator is also not able to execute anything concurrently while a script is used. The usage of preprocessing scripts that heavily modify the model should be kept to a minimum. </p>
<h2 id="error-handling">Error Handling</h2>
<p>When reporting errors during generation the natural thing to use is exceptions as most of the code that is written in MPS generators is Java. But doing so has some disadvantages. </p>
<ul>
<li>It stops generation immediately. The user only get's single error message if there are multiple errors during generator the user can only fix the first, then has to regenerated, get the next error and start over. This can be a very frustrating process.</li>
<li>There is no way to point the user to the input that caused the error. The exception will contain a link to the rule that cause it but there is not additional information useful for the user to debug. If transient models are turned on the user might be able to see the intermediate state which caused the error but it's often hard to guess from the which node in the original model caused it.</li>
</ul>
<p>It is much better do something like this:</p>
<pre><code>genContext.show error &quot;something went wrong&quot; -&gt; genContext.get original copied input for (node)
</code></pre>

<p>This will stop generation after the current generation phase is complete. No other generators will execute afterwards, but it will collect all errors from the currently executed generator. It also allows to specify a node where the user is taken to when the messages is clicked. Together with the <code>genContext.get original copied input for (node)</code> pattern it takes the user directly to the input in the original model. </p>
<h2 id="copy-and-reduce">Copy and Reduce</h2>
<p>When generating output from a list of items or a single child node the first idea if often to use a <code>$LOOP$</code> macro or to do the transformation <em>in place</em>. While this looks easy in the first place it also limits extensibility. It is often much better to avoid this kind of pattern and use a combination for <code>$COPY_SRC$</code>/<code>$COPY_SRCL$</code> and a reduction rule for the concept. This allows extensions to contribute their own reduction rules for their concepts. Incase a <code>$LOOP$</code> macro would be used the only option to extend the generator would be to essentially copy the complete mapping and have the generator run before the one of the extended language is invoked. </p>
<h2 id="prefer-switches-over-ifs">Prefer Switches over Ifs</h2>
<h2 id="predefined-generator-plans">Predefined Generator Plans</h2>
<p>In some cases defining a static generation plan can be very useful and simplify the view on which generators are engaged at which point during the generation. Though this is mostly the last option one want to take. At the moment the extensibility story for predefined generator plans is pretty limited compared to the dynamic approach with priorities. Currently you can only contribute generators to the predefined plan via extension dependency to a generator that is involved in the generation plan this generator is the executed in the same step as the extended generator. It can also cause problems in conjunction with node/editor tests. If a DevKit with a generation plan and this DevKit is used in tests, this can cause that MPS would not consider the generators of the test language. As mentioned above this is a solution that currently doesn't widely apply especially not if your languages are meant to be extended. But in some contexts where extensibility is not the main concern or even undesired using predefined generation plans can help.</p>
            
          
        </div>
      </div>
    </div>
    <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
      <div class="sphinxsidebarwrapper">
        
  <h1 class="logo"><a href="..">Towards Maintainable MPS Generators</a></h1>



        
          



<h3>Table Of Contents</h3>

<nav>
  
  
    <ul>
    
      <li><a href="#detecting-tests">Detecting Tests</a></li>
      <ul>
    
  </ul>
    
      <li><a href="#preprocessing">Preprocessing</a></li>
      <ul>
    
  </ul>
    
      <li><a href="#error-handling">Error Handling</a></li>
      <ul>
    
  </ul>
    
      <li><a href="#copy-and-reduce">Copy and Reduce</a></li>
      <ul>
    
  </ul>
    
      <li><a href="#prefer-switches-over-ifs">Prefer Switches over Ifs</a></li>
      <ul>
    
  </ul>
    
      <li><a href="#predefined-generator-plans">Predefined Generator Plans</a></li>
      <ul>
    
  </ul>
    
  </ul>
  

  
</nav>
          
  <h3>Related Topics</h3>
  <ul>
    
      <li>Previous: <a href=".." title="previous chapter">
        Home
      </a></li>
    
    
      <li>Next: <a href="../Complex/" title="next chapter">
        Complex Multistage Generators
      </a></li>
    
  </ul>

        
        <div id="searchbox" style="display: none;" role="search">
  <h3>Quick search</h3>
  <form class="search" action="../search.html" method="get">
    <input name="q" type="text">
    <input value="Go" type="submit">
  </form>
  <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
  </p>
</div>
<script type="text/javascript">
  document.getElementById("searchbox").style.display = "block";
</script>
      </div>
    </div>
    <div class="clearer"></div>
  </div>

  
    <div class="footer">
      
      
        
        Powered by <a href="http://www.mkdocs.org">MkDocs 0.17.2</a>
        &amp; <a href="https://github.com/iamale/mkdocs-alabaster">Alabaster</a>
      
    </div>
  

  <!--
  MkDocs version      : 0.17.2
  Docs Build Date UTC : 2018-04-01 20:56:58
  -->
</body>
</html>