{
    "docs": [
        {
            "location": "/",
            "text": "Towards Maintainable Generators\n\n\nThis website aims to provide a set of best practices for maintainable generators and a set of rules when to apply them. \n\n\nIntroduction\n\n\nAs any software generators can get complex and hard to maintain therefore it is important to write them in a way that makes them easy to maintain. Over the past years we have gathered quite a lot experience in writing theses generators. This website tries the provide a set of best practices and rules when theses practices might get applied. It's not meant as a fixed set of rules that should be blindly followed but as guidelines. We will discuss the tradeoffs and aspects to consider extensively. \n\n\nMaintainability\n\n\nWhat does maintainability mean in this context? On the one hand it is about the ability to change/delete/rewrite parts of the generator chain without affecting parts prior or later in the chain. On the other hand it's about writing readable generators which can easily be understood and reasoned",
            "title": "Home"
        },
        {
            "location": "/#towards-maintainable-generators",
            "text": "This website aims to provide a set of best practices for maintainable generators and a set of rules when to apply them.",
            "title": "Towards Maintainable Generators"
        },
        {
            "location": "/#introduction",
            "text": "As any software generators can get complex and hard to maintain therefore it is important to write them in a way that makes them easy to maintain. Over the past years we have gathered quite a lot experience in writing theses generators. This website tries the provide a set of best practices and rules when theses practices might get applied. It's not meant as a fixed set of rules that should be blindly followed but as guidelines. We will discuss the tradeoffs and aspects to consider extensively.",
            "title": "Introduction"
        },
        {
            "location": "/#maintainability",
            "text": "What does maintainability mean in this context? On the one hand it is about the ability to change/delete/rewrite parts of the generator chain without affecting parts prior or later in the chain. On the other hand it's about writing readable generators which can easily be understood and reasoned",
            "title": "Maintainability"
        },
        {
            "location": "/Best Practices/",
            "text": "Best Practices\n\n\nDetecting Tests\n\n\nIn some cases generators should not transform node when they are used in tests as some of their assumptions about the structure of their input might not hold in tests. Tests often test nodes in isolation which doesn't work well with more complex generators that depend on some context.\n\n\nUse the \nIsInTestsExpression\n from the \ncom.mbeddr.mpsutil.blutil.genUtil\n language, which is part of the MPS-extensions:\n\n\nis applicable:\n    (genContext) -> boolean {\n        !is-in-tests;\n    }\n\n\n\n\nOr alternatively:\n\n\n--- is applicable ---\n(genContext)->boolean {\n  !genContext.originalModel.nodes(<all>).any({~it => it.concept.getLanguage().getQualifiedName().startsWith(\"jetbrains.mps.lang.test\"); });\n}\n\n\n\n\nIf you use the later it might make sense to move this code into a helper class and use it that in the various places of your code bases.\n\n\nPreprocessing\n\n\nIn scenarios where the structure of the input model is significantly different form the output structure it is often handy to use preprocessing scripts written in Java rather than reduction or weaving rules. Another sometimes useful benefit is that debugging Java code can be easier than the declarative and interpreted rules of the generator. \n\n\nAn example where preprocessing can make a lot of sense is inout collection for generation. If the generation target is for instance a XML file with a specific structure but the input model allows the user to freely place these elements preprocessing can collect all these contents and place them under a single node with a structure closer to the one of output. \n\n\nIn addition to using preprocessing for to change the structure of the input it is also handy to have intermediate language who's sole purpose is to ease generation. These languages often contain concepts that user does not need to specify explicitly in the input because they can be derived from the input. But during generation it often simplifies the generators if these elements are explicitly in the model because they can be generated by simple means of reduction rules. An example for this would be a generator that generates serialisation logic for data structures but could derive the data types for certain input automatically (e.g. boolean). The actual generator to produce the serialisation logic is much simpler to write when these data types are explicitly in the model. In this case the preprocessing would add these information.\n\n\nPreprocessing comes at a cost, as it's not as declarative as the generator language tracing has to be done manually via the \nTracingUtil\ns \nfillOriginalNode\n. Also registering inputs and outputs to mapping label needs to be done explicitly via: \ngenContext.label input to output as myLabel;\n. The generator is also not able to execute anything concurrently while a script is used. The usage of preprocessing scripts that heavily modify the model should be kept to a minimum. \n\n\nError Handling\n\n\nWhen reporting errors during generation the natural thing to use is exceptions as most of the code that is written in MPS generators is Java. But doing so has some disadvantages. \n\n\n\n\nIt stops generation immediately. The user only get's single error message if there are multiple errors during generator the user can only fix the first, then has to regenerated, get the next error and start over. This can be a very frustrating process.\n\n\nThere is no way to point the user to the input that caused the error. The exception will contain a link to the rule that cause it but there is not additional information useful for the user to debug. If transient models are turned on the user might be able to see the intermediate state which caused the error but it's often hard to guess from the which node in the original model caused it.\n\n\n\n\nIt is much better do something like this:\n\n\ngenContext.show error \"something went wrong\" -> genContext.get original copied input for (node)\n\n\n\n\nThis will stop generation after the current generation phase is complete. No other generators will execute afterwards, but it will collect all errors from the currently executed generator. It also allows to specify a node where the user is taken to when the messages is clicked. Together with the \ngenContext.get original copied input for (node)\n pattern it takes the user directly to the input in the original model. \n\n\nCopy and Reduce\n\n\nWhen generating output from a list of items or a single child node the first idea if often to use a \n$LOOP$\n macro or to do the transformation \nin place\n. While this looks easy in the first place it also limits extensibility. It is often much better to avoid this kind of pattern and use a combination for \n$COPY_SRC$\n/\n$COPY_SRCL$\n and a reduction rule for the concept. This allows extensions to contribute their own reduction rules for their concepts. Incase a \n$LOOP$\n macro would be used the only option to extend the generator would be to essentially copy the complete mapping and have the generator run before the one of the extended language is invoked. \n\n\nPrefer Switches over Ifs\n\n\nPredefined Generator Plans\n\n\nIn some cases defining a static generation plan can be very useful and simplify the view on which generators are engaged at which point during the generation. Though this is mostly the last option one want to take. At the moment the extensibility story for predefined generator plans is pretty limited compared to the dynamic approach with priorities. Currently you can only contribute generators to the predefined plan via extension dependency to a generator that is involved in the generation plan this generator is the executed in the same step as the extended generator. It can also cause problems in conjunction with node/editor tests. If a DevKit with a generation plan and this DevKit is used in tests, this can cause that MPS would not consider the generators of the test language. As mentioned above this is a solution that currently doesn't widely apply especially not if your languages are meant to be extended. But in some contexts where extensibility is not the main concern or even undesired using predefined generation plans can help.",
            "title": "Best Practices"
        },
        {
            "location": "/Best Practices/#best-practices",
            "text": "",
            "title": "Best Practices"
        },
        {
            "location": "/Best Practices/#detecting-tests",
            "text": "In some cases generators should not transform node when they are used in tests as some of their assumptions about the structure of their input might not hold in tests. Tests often test nodes in isolation which doesn't work well with more complex generators that depend on some context.  Use the  IsInTestsExpression  from the  com.mbeddr.mpsutil.blutil.genUtil  language, which is part of the MPS-extensions:  is applicable:\n    (genContext) -> boolean {\n        !is-in-tests;\n    }  Or alternatively:  --- is applicable ---\n(genContext)->boolean {\n  !genContext.originalModel.nodes(<all>).any({~it => it.concept.getLanguage().getQualifiedName().startsWith(\"jetbrains.mps.lang.test\"); });\n}  If you use the later it might make sense to move this code into a helper class and use it that in the various places of your code bases.",
            "title": "Detecting Tests"
        },
        {
            "location": "/Best Practices/#preprocessing",
            "text": "In scenarios where the structure of the input model is significantly different form the output structure it is often handy to use preprocessing scripts written in Java rather than reduction or weaving rules. Another sometimes useful benefit is that debugging Java code can be easier than the declarative and interpreted rules of the generator.   An example where preprocessing can make a lot of sense is inout collection for generation. If the generation target is for instance a XML file with a specific structure but the input model allows the user to freely place these elements preprocessing can collect all these contents and place them under a single node with a structure closer to the one of output.   In addition to using preprocessing for to change the structure of the input it is also handy to have intermediate language who's sole purpose is to ease generation. These languages often contain concepts that user does not need to specify explicitly in the input because they can be derived from the input. But during generation it often simplifies the generators if these elements are explicitly in the model because they can be generated by simple means of reduction rules. An example for this would be a generator that generates serialisation logic for data structures but could derive the data types for certain input automatically (e.g. boolean). The actual generator to produce the serialisation logic is much simpler to write when these data types are explicitly in the model. In this case the preprocessing would add these information.  Preprocessing comes at a cost, as it's not as declarative as the generator language tracing has to be done manually via the  TracingUtil s  fillOriginalNode . Also registering inputs and outputs to mapping label needs to be done explicitly via:  genContext.label input to output as myLabel; . The generator is also not able to execute anything concurrently while a script is used. The usage of preprocessing scripts that heavily modify the model should be kept to a minimum.",
            "title": "Preprocessing"
        },
        {
            "location": "/Best Practices/#error-handling",
            "text": "When reporting errors during generation the natural thing to use is exceptions as most of the code that is written in MPS generators is Java. But doing so has some disadvantages.    It stops generation immediately. The user only get's single error message if there are multiple errors during generator the user can only fix the first, then has to regenerated, get the next error and start over. This can be a very frustrating process.  There is no way to point the user to the input that caused the error. The exception will contain a link to the rule that cause it but there is not additional information useful for the user to debug. If transient models are turned on the user might be able to see the intermediate state which caused the error but it's often hard to guess from the which node in the original model caused it.   It is much better do something like this:  genContext.show error \"something went wrong\" -> genContext.get original copied input for (node)  This will stop generation after the current generation phase is complete. No other generators will execute afterwards, but it will collect all errors from the currently executed generator. It also allows to specify a node where the user is taken to when the messages is clicked. Together with the  genContext.get original copied input for (node)  pattern it takes the user directly to the input in the original model.",
            "title": "Error Handling"
        },
        {
            "location": "/Best Practices/#copy-and-reduce",
            "text": "When generating output from a list of items or a single child node the first idea if often to use a  $LOOP$  macro or to do the transformation  in place . While this looks easy in the first place it also limits extensibility. It is often much better to avoid this kind of pattern and use a combination for  $COPY_SRC$ / $COPY_SRCL$  and a reduction rule for the concept. This allows extensions to contribute their own reduction rules for their concepts. Incase a  $LOOP$  macro would be used the only option to extend the generator would be to essentially copy the complete mapping and have the generator run before the one of the extended language is invoked.",
            "title": "Copy and Reduce"
        },
        {
            "location": "/Best Practices/#prefer-switches-over-ifs",
            "text": "",
            "title": "Prefer Switches over Ifs"
        },
        {
            "location": "/Best Practices/#predefined-generator-plans",
            "text": "In some cases defining a static generation plan can be very useful and simplify the view on which generators are engaged at which point during the generation. Though this is mostly the last option one want to take. At the moment the extensibility story for predefined generator plans is pretty limited compared to the dynamic approach with priorities. Currently you can only contribute generators to the predefined plan via extension dependency to a generator that is involved in the generation plan this generator is the executed in the same step as the extended generator. It can also cause problems in conjunction with node/editor tests. If a DevKit with a generation plan and this DevKit is used in tests, this can cause that MPS would not consider the generators of the test language. As mentioned above this is a solution that currently doesn't widely apply especially not if your languages are meant to be extended. But in some contexts where extensibility is not the main concern or even undesired using predefined generation plans can help.",
            "title": "Predefined Generator Plans"
        },
        {
            "location": "/Complex/",
            "text": "",
            "title": "Complex Multistage Generators"
        },
        {
            "location": "/Multiple_Outputs/",
            "text": "Multiple Outputs from a Single Model",
            "title": "Multiple Output from a Single Model"
        },
        {
            "location": "/Multiple_Outputs/#multiple-outputs-from-a-single-model",
            "text": "",
            "title": "Multiple Outputs from a Single Model"
        },
        {
            "location": "/Pitfalls/",
            "text": "Common Pitfalls\n\n\nThe Generator language has a couple of pecularities that inexperienced developers tend to waste a lot of time on.  This listing is by no means comprehensive, but is provided in the hope that it might save future users of the Generator language some nerves.\n\n\nBroken References\n\n\nIn MPS, References break when their target node is detached. This does not only happen when explicitly calling the .detach()-method on a node, but also happens automatically when \n\n\n\n\nan existing node is assigned to a position in another Model. When moving nodes between models it is hence strongly recommended to copy them using the .copy-method\n\n\nthe target node is contained in a root that is deleted (for instance via an Abandon-Rule or because of a Root-Mapping-Rule with \u201ckeep input root=false\u201d). It is hence recommended to use \u201ckeep input root=true\u201d whenever possible and to use Abandon Rules with caution.\n\n\nThe target node is replaced using the .replace_with() or .replace_with_new() methods.\n\n\nA Reduction Rule is applied to the target node.\n\n\n\n\nTracing\n\n\nWhen running a generator, an input model is transformed step-wise into an output model and in the process copied at least once per step. For debugging purposes, MPS maintains tracing information along this process, that connects each node with its predecessors / successors in previous / subsequent steps.\nThis information can also be used within the generator itself, to trace nodes backwards to their origin using genContext.get original copied input by output() or forwards to the output model of the current step using genContext.get copied output by input().\n\n\nMPS is able to maintain this tracing information fully automatic as long as no baseLanguage is involved. However, when pre-/postprocessing-Skripts or baseLanguage-Code within Makros modifies the model, the chain of tracing information may be broken and affected nodes can no longer be traced (the methods mentioned above will simply return the node they were given as an argument in that case).\n\n\nThere is, however, one methods for maintaining trace information even when modifying the model with baseLanguage: genContext.copy with trace(node) will create a copy of node that contrary to node.copy allows the resulting node to be traced. It is hence recommended to use copy with trace instead of copy whenever possible.\n\n\nMapping Labels\n\n\nOrder of Evaluation\n\n\nIn general, the order of evaluation for Generator Templates is undefined. There is no reliable rule like \u201cleft-to-right\u201d, \u201ctop-to-bottom\u201d, etc. Even though the order seems to be deterministic within an MPS instance on one particular computer it can vary between computers and versions of MPS. Most probably this is an intentional design decision that should make MPS Templates highly parallelizable. However, updating a mapping label constitutes a side-effect and side-effects somewhat collide with this concept of parallelism. It is hence EXTREMELY IMPORTANT to use other mechanisms for ensuring that mapping labels are filled prior to being accessed.\n\n\nTwo Mechanisms that work well in this respect are\n\n\n\n\n$MAP_SRC$-Makros have post-processing-method that is invoked in the very last phase of generation. A good strategy for reading values from a mapping label is hence to\n\n\nUse a $MAP_SRC$-Makro to create concepts that must be retrieved from a mapping label.\n\n\nIn the mapping-method, create an instance of an intermediate concept (often called a \u201cProxy\u201d) to store all information necessary to retrieve the actual result from the mapping label.\n\n\nIn the post-processing-method, retrieve the actual result from the mapping label (which in this phase has surely been filled) and substitute it for the outputNode (which is the Proxy) using the .replace with-method.\n\n\n\n\n\n\nReference Macros: When no additional information is necessary to retrieve a result from a mapping label, one can also use a Reference Makro. Reference Makros are also resolved in the very last phase of generation and hence also provide a safe way to use mapping labels.\n\n\n\n\nImplicit node copies\n\n\nWhen running a generator, MPS arranges the mapping configurations into so-called \u201csteps\u201d. Each step takes an input model and transforms it into an output model, which is then used as the input model for the next subsequent step. Preprocessing / postprocessing skripts are run in their own mini-step before / after the mapping configuration. Since it is possible for a generator to also modify its input-model, MPS protects the generation input (lets call it M) by copying it into a first transient model (called M@0) as a very first step. For this reason, no template (not even the very first one) applied within a generator does work on the \u201coriginal\u201d model. They all work on copies thereof.\n\n\nIt follows that, when using a mapping label to map some sort of source nodes to some sort of target nodes, then these source nodes do NOT come from the original input model, but from some intermediate transient model (by the way: One can determine the model any node in MPS \u201clives in\u201d, using the node.model-syntax). Furthermore, since mapping labels are implemented using Java HashMaps, querying the mapping label with any other node (even when it is a copy of the one used as a key and hence has the same concept, NodeID, etc.) will NOT work.\n\n\nFortunately, when trace information is maintained properly (see Section \u201cTracing\u201d above), then Method genContext.get original copied input by output for (node) provides a way to trace every node in our intermediate model back to a node in the original input model that it was derived from. A good strategy to avoid the problem outlined above where the constant copying of nodes practically prohibits the use of mapping labels, is to\n\n\n\n\nproperly maintain tracing information.\n\n\nuse genContext.get original copied input by output for (node) on the nodes used as keys in the mapping label. For instance, when providing a $LOOP$-Makro with a mapping label, then the \u201citeration sequence\u201d-method should apply it to every element of its result-sequence as those elements will be used as keys in the mapping label.\n\n\nalso use genContext.get original copied input by output for (node) to the node used as key when querying the mapping label. This will ensure that both the key stored in the HashMap as well as the node used for querying are from the same model and - since NodeIDs are unique within a model, having the same nodeID implies that they are the same object.\n\n\nSince the value retrieved from a mapping label might also be nodes from some intermediate transient model, it is often necessary to apply genContext.get copied output by input for (node) to the result to ensure that references do not cross model boundaries.\n\n\n\n\nTemplate Calls with Variables\n\n\nFrom time to time it becomes necessary to factor some part of a larger template into a separate template fragment to make it reusable. Such template fragments can be invoked using the $CALL$ Node Macro and can also take parameters, just like functions. However, for some reason passing the value of a variable (defines using the $VAR$ Node Macro) as an actual argument causes an IllegalArgumentException, which in turn causes the result of this template call to be discarded.\nAs an Example:\n\n\n$VAR$ x $CALL$ template\n\nInspector of $VAR$\n     | type: <result-type>\n     | value: (genContext, operationContext, node) -> <result-type> { <expression> }\n\nInspector of $CALL$\n     | template: template(genContext.x)\n\n\n\n\nwill cause an IllegalArgumentException, while\n\n\n$CALL$ template\n\nInspector of $CALL$\n     | template: template(<expression>)\n\n\n\n\nworks, although the two should be equivalent.\nUnfortunately, I cannot tell why this happens, I just encountered this phenomenon several times and was always able to get things to run by removing the $VAR$ and replacing all its occurrences with the \n used to initialize it.",
            "title": "Common Pitfalls"
        },
        {
            "location": "/Pitfalls/#common-pitfalls",
            "text": "The Generator language has a couple of pecularities that inexperienced developers tend to waste a lot of time on.  This listing is by no means comprehensive, but is provided in the hope that it might save future users of the Generator language some nerves.",
            "title": "Common Pitfalls"
        },
        {
            "location": "/Pitfalls/#broken-references",
            "text": "In MPS, References break when their target node is detached. This does not only happen when explicitly calling the .detach()-method on a node, but also happens automatically when    an existing node is assigned to a position in another Model. When moving nodes between models it is hence strongly recommended to copy them using the .copy-method  the target node is contained in a root that is deleted (for instance via an Abandon-Rule or because of a Root-Mapping-Rule with \u201ckeep input root=false\u201d). It is hence recommended to use \u201ckeep input root=true\u201d whenever possible and to use Abandon Rules with caution.  The target node is replaced using the .replace_with() or .replace_with_new() methods.  A Reduction Rule is applied to the target node.",
            "title": "Broken References"
        },
        {
            "location": "/Pitfalls/#tracing",
            "text": "When running a generator, an input model is transformed step-wise into an output model and in the process copied at least once per step. For debugging purposes, MPS maintains tracing information along this process, that connects each node with its predecessors / successors in previous / subsequent steps.\nThis information can also be used within the generator itself, to trace nodes backwards to their origin using genContext.get original copied input by output() or forwards to the output model of the current step using genContext.get copied output by input().  MPS is able to maintain this tracing information fully automatic as long as no baseLanguage is involved. However, when pre-/postprocessing-Skripts or baseLanguage-Code within Makros modifies the model, the chain of tracing information may be broken and affected nodes can no longer be traced (the methods mentioned above will simply return the node they were given as an argument in that case).  There is, however, one methods for maintaining trace information even when modifying the model with baseLanguage: genContext.copy with trace(node) will create a copy of node that contrary to node.copy allows the resulting node to be traced. It is hence recommended to use copy with trace instead of copy whenever possible.",
            "title": "Tracing"
        },
        {
            "location": "/Pitfalls/#mapping-labels",
            "text": "",
            "title": "Mapping Labels"
        },
        {
            "location": "/Pitfalls/#order-of-evaluation",
            "text": "In general, the order of evaluation for Generator Templates is undefined. There is no reliable rule like \u201cleft-to-right\u201d, \u201ctop-to-bottom\u201d, etc. Even though the order seems to be deterministic within an MPS instance on one particular computer it can vary between computers and versions of MPS. Most probably this is an intentional design decision that should make MPS Templates highly parallelizable. However, updating a mapping label constitutes a side-effect and side-effects somewhat collide with this concept of parallelism. It is hence EXTREMELY IMPORTANT to use other mechanisms for ensuring that mapping labels are filled prior to being accessed.  Two Mechanisms that work well in this respect are   $MAP_SRC$-Makros have post-processing-method that is invoked in the very last phase of generation. A good strategy for reading values from a mapping label is hence to  Use a $MAP_SRC$-Makro to create concepts that must be retrieved from a mapping label.  In the mapping-method, create an instance of an intermediate concept (often called a \u201cProxy\u201d) to store all information necessary to retrieve the actual result from the mapping label.  In the post-processing-method, retrieve the actual result from the mapping label (which in this phase has surely been filled) and substitute it for the outputNode (which is the Proxy) using the .replace with-method.    Reference Macros: When no additional information is necessary to retrieve a result from a mapping label, one can also use a Reference Makro. Reference Makros are also resolved in the very last phase of generation and hence also provide a safe way to use mapping labels.",
            "title": "Order of Evaluation"
        },
        {
            "location": "/Pitfalls/#implicit-node-copies",
            "text": "When running a generator, MPS arranges the mapping configurations into so-called \u201csteps\u201d. Each step takes an input model and transforms it into an output model, which is then used as the input model for the next subsequent step. Preprocessing / postprocessing skripts are run in their own mini-step before / after the mapping configuration. Since it is possible for a generator to also modify its input-model, MPS protects the generation input (lets call it M) by copying it into a first transient model (called M@0) as a very first step. For this reason, no template (not even the very first one) applied within a generator does work on the \u201coriginal\u201d model. They all work on copies thereof.  It follows that, when using a mapping label to map some sort of source nodes to some sort of target nodes, then these source nodes do NOT come from the original input model, but from some intermediate transient model (by the way: One can determine the model any node in MPS \u201clives in\u201d, using the node.model-syntax). Furthermore, since mapping labels are implemented using Java HashMaps, querying the mapping label with any other node (even when it is a copy of the one used as a key and hence has the same concept, NodeID, etc.) will NOT work.  Fortunately, when trace information is maintained properly (see Section \u201cTracing\u201d above), then Method genContext.get original copied input by output for (node) provides a way to trace every node in our intermediate model back to a node in the original input model that it was derived from. A good strategy to avoid the problem outlined above where the constant copying of nodes practically prohibits the use of mapping labels, is to   properly maintain tracing information.  use genContext.get original copied input by output for (node) on the nodes used as keys in the mapping label. For instance, when providing a $LOOP$-Makro with a mapping label, then the \u201citeration sequence\u201d-method should apply it to every element of its result-sequence as those elements will be used as keys in the mapping label.  also use genContext.get original copied input by output for (node) to the node used as key when querying the mapping label. This will ensure that both the key stored in the HashMap as well as the node used for querying are from the same model and - since NodeIDs are unique within a model, having the same nodeID implies that they are the same object.  Since the value retrieved from a mapping label might also be nodes from some intermediate transient model, it is often necessary to apply genContext.get copied output by input for (node) to the result to ensure that references do not cross model boundaries.",
            "title": "Implicit node copies"
        },
        {
            "location": "/Pitfalls/#template-calls-with-variables",
            "text": "From time to time it becomes necessary to factor some part of a larger template into a separate template fragment to make it reusable. Such template fragments can be invoked using the $CALL$ Node Macro and can also take parameters, just like functions. However, for some reason passing the value of a variable (defines using the $VAR$ Node Macro) as an actual argument causes an IllegalArgumentException, which in turn causes the result of this template call to be discarded.\nAs an Example:  $VAR$ x $CALL$ template\n\nInspector of $VAR$\n     | type: <result-type>\n     | value: (genContext, operationContext, node) -> <result-type> { <expression> }\n\nInspector of $CALL$\n     | template: template(genContext.x)  will cause an IllegalArgumentException, while  $CALL$ template\n\nInspector of $CALL$\n     | template: template(<expression>)  works, although the two should be equivalent.\nUnfortunately, I cannot tell why this happens, I just encountered this phenomenon several times and was always able to get things to run by removing the $VAR$ and replacing all its occurrences with the   used to initialize it.",
            "title": "Template Calls with Variables"
        }
    ]
}